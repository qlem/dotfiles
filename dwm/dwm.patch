--- dwm.c.orig	2020-11-11 17:20:30.489253255 +0100
+++ dwm.c	2020-12-20 22:28:05.932287192 +0100
@@ -64,8 +64,8 @@
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
 	int i;
@@ -141,12 +141,18 @@
 	int monitor;
 } Rule;
 
+typedef struct {
+	unsigned int top, bottom, left, right;
+	unsigned int minc, tinc;
+} Gap;
+
 /* function declarations */
 static void applyrules(Client *c);
 static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
+static void attachbottom(Client *c);
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -209,6 +215,8 @@
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *);
+static void tilemastergaps(Gap *gap, int nmaster, int nstack, unsigned int i);
+static void tilestackgaps(Gap *gap, int nmaster, int nstack, unsigned int i);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void toggletag(const Arg *arg);
@@ -233,6 +241,11 @@
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void focusmaster(const Arg *arg);
+static void bstack(Monitor *m);
+static void bstackmastergaps(Gap *gap, int nmaster, int nstack, unsigned int i);
+static void bstackstackgaps(Gap *gap, int nmaster, int nstack, unsigned int i);
+static void movestack(const Arg *arg);
 
 /* variables */
 static const char broken[] = "broken";
@@ -407,6 +420,18 @@
 }
 
 void
+attachbottom(Client *c)
+{
+	Client *below = c->mon->clients;
+	for (; below && below->next; below = below->next);
+	c->next = NULL;
+	if (below)
+		below->next = c;
+	else
+		c->mon->clients = c;
+}
+
+void
 attachstack(Client *c)
 {
 	c->snext = c->mon->stack;
@@ -439,10 +464,8 @@
 			arg.ui = 1 << i;
 		} else if (ev->x < x + blw)
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - TEXTW(stext))
-			click = ClkStatusText;
 		else
-			click = ClkWinTitle;
+			click = ClkStatusText;
 	} else if ((c = wintoclient(ev->window))) {
 		focus(c);
 		restack(selmon);
@@ -702,7 +725,7 @@
 	Client *c;
 
 	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
+	if (m == selmon || 1) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
 		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
 		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
@@ -729,15 +752,8 @@
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
 
 	if ((w = m->ww - sw - x) > bh) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
 			drw_rect(drw, x, 0, w, bh, 1, 1);
-		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
@@ -1062,7 +1078,7 @@
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
-	attach(c);
+	attachbottom(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 		(unsigned char *) &(c->win), 1);
@@ -1235,11 +1251,8 @@
 			drawbars();
 			break;
 		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
 			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
 		if (ev->atom == netatom[NetWMWindowType])
 			updatewindowtype(c);
 	}
@@ -1417,7 +1430,7 @@
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	attach(c);
+	attachbottom(c);
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
@@ -1675,9 +1688,10 @@
 {
 	unsigned int i, n, h, mw, my, ty;
 	Client *c;
+	Gap gap;
 
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
+	if (n == 0 || m->nmaster > n)
 		return;
 
 	if (n > m->nmaster)
@@ -1685,18 +1699,73 @@
 	else
 		mw = m->ww;
 	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
+		if (c->mon->lt[c->mon->sellt]->arrange == monocle || n == 1) {
+			// todo - remove border from client
+			resize(c, m->wx, m->wy, mw, m->wh, 0);
+		} else if (i < m->nmaster) {
 			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
-			my += HEIGHT(c);
+			tilemastergaps(&gap, m->nmaster, n - m->nmaster, i);
+			resize(c, m->wx + gap.left, m->wy + my + gap.top, mw - (2*c->bw) - gap.left
+				- gap.right, h - (2*c->bw) - gap.top - gap.bottom, 0);
+			my += HEIGHT(c) + gap.minc;
 		} else {
 			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			ty += HEIGHT(c);
+			tilestackgaps(&gap, m->nmaster, n - m->nmaster, i - m->nmaster);
+			resize(c, m->wx + mw + gap.left, m->wy + ty + gap.top, m->ww - mw - (2*c->bw)
+				- gap.left - gap.right, h - (2*c->bw) - gap.top - gap.bottom, 0);
+			ty += HEIGHT(c) + gap.tinc;
 		}
 }
 
 void
+tilemastergaps(Gap *gap, int nmaster, int nstack, unsigned int i) {
+	if (nmaster == 1) {
+		gap->top = gap->left = gap->bottom = gappx;
+		gap->right = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx * 2;
+	} else if (i == 0) {
+		gap->top = gap->left = gappx;
+		gap->bottom = gappx / 2;
+		gap->right = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx + gappx / 2;
+	} else if (i + 1 < nmaster) {
+		gap->top = gap->bottom = gappx / 2;
+		gap->left = gappx;
+		gap->right = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx;
+	} else {
+		gap->top = gappx / 2;
+		gap->left = gap->bottom = gappx;
+		gap->right = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx + gappx / 2;
+	}
+}
+
+void
+tilestackgaps(Gap *gap, int nmaster, int nstack, unsigned int i) {
+	if (nstack == 1) {
+		gap->top = gap->right = gap->bottom = gappx;
+		gap->left = nmaster ? gappx / 2 : gappx;
+		gap->tinc = gappx * 2;
+	} else if (i == 0) {
+		gap->top = gap->right = gappx;
+		gap->bottom = gappx / 2;
+		gap->left = nmaster ? gappx / 2 : gappx;
+		gap->tinc = gappx + gappx / 2;
+	} else if (i + 1 < nstack) {
+		gap->top = gap->bottom = gappx / 2;
+		gap->left = nmaster ? gappx / 2 : gappx;
+		gap->right = gappx;
+		gap->tinc = gappx;
+	} else {
+		gap->top = gappx / 2;
+		gap->left = nmaster ? gappx / 2 : gappx;
+		gap->right = gap->bottom = gappx;
+		gap->tinc = gappx + gappx / 2;
+	}
+}
+
+void
 togglebar(const Arg *arg)
 {
 	selmon->showbar = !selmon->showbar;
@@ -1897,7 +1966,7 @@
 					m->clients = c->next;
 					detachstack(c);
 					c->mon = mons;
-					attach(c);
+					attachbottom(c);
 					attachstack(c);
 				}
 				if (m == selmon)
@@ -1987,9 +2056,12 @@
 void
 updatestatus(void)
 {
+	Monitor* m;
+
 	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
 		strcpy(stext, "dwm-"VERSION);
-	drawbar(selmon);
+	for(m = mons; m; m = m->next)
+		drawbar(m);
 }
 
 void
@@ -2147,3 +2219,155 @@
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
+void
+movestack(const Arg *arg) {
+	Client *c = NULL, *p = NULL, *pc = NULL, *i;
+
+	if(arg->i > 0) {
+		/* find the client after selmon->sel */
+		for(c = selmon->sel->next; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+		if(!c)
+			for(c = selmon->clients; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+
+	}
+	else {
+		/* find the client before selmon->sel */
+		for(i = selmon->clients; i != selmon->sel; i = i->next)
+			if(ISVISIBLE(i) && !i->isfloating)
+				c = i;
+		if(!c)
+			for(; i; i = i->next)
+				if(ISVISIBLE(i) && !i->isfloating)
+					c = i;
+	}
+	/* find the client before selmon->sel and c */
+	for(i = selmon->clients; i && (!p || !pc); i = i->next) {
+		if(i->next == selmon->sel)
+			p = i;
+		if(i->next == c)
+			pc = i;
+	}
+
+	/* swap c and selmon->sel selmon->clients in the selmon->clients list */
+	if(c && c != selmon->sel) {
+		Client *temp = selmon->sel->next==c?selmon->sel:selmon->sel->next;
+		selmon->sel->next = c->next==selmon->sel?c:c->next;
+		c->next = temp;
+
+		if(p && p != c)
+			p->next = c;
+		if(pc && pc != selmon->sel)
+			pc->next = selmon->sel;
+
+		if(selmon->sel == selmon->clients)
+			selmon->clients = c;
+		else if(c == selmon->clients)
+			selmon->clients = selmon->sel;
+
+		arrange(selmon);
+	}
+}
+
+static void
+bstack(Monitor *m) {
+	int w, h, mh, mx, tx, ty, tw;
+	unsigned int i, n;
+	Client *c;
+	Gap gap;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (n == 0 || m->nmaster > n)
+		return;
+
+	if (n > m->nmaster) {
+		mh = m->nmaster ? m->mfact * m->wh : 0;
+		tw = m->ww / (n - m->nmaster);
+		ty = m->wy + mh;
+	} else {
+		mh = m->wh;
+		tw = m->ww;
+		ty = m->wy;
+	}
+	for (i = mx = 0, tx = m->wx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (c->mon->lt[c->mon->sellt]->arrange == monocle || n == 1) {
+			// todo - remove border from client
+			resize(c, m->wx, m->wy, m->ww, m->wh, 0);
+		} else if (i < m->nmaster) {
+			w = (m->ww - mx) / (MIN(n, m->nmaster) - i);
+			bstackmastergaps(&gap, m->nmaster, n - m->nmaster, i);
+			resize(c, m->wx + mx + gap.left, m->wy + gap.top, w - (2 * c->bw) - gap.left
+				- gap.right, mh - (2 * c->bw) - gap.top - gap.bottom, 0);
+			mx += WIDTH(c) + gap.minc;
+		} else {
+			h = m->wh - mh;
+			bstackstackgaps(&gap, m->nmaster, n - m->nmaster, i - m->nmaster);
+			resize(c, tx + gap.left, ty + gap.top, tw - (2 * c->bw) - gap.left - gap.right,
+				h - (2 * c->bw) - gap.top - gap.bottom, 0);
+			/* if (tw != m->ww) */
+			tx += WIDTH(c) + gap.tinc;
+		}
+	}
+}
+
+void
+bstackmastergaps(Gap *gap, int nmaster, int nstack, unsigned int i) {
+	if (nmaster == 1) {
+		gap->top = gap->left = gap->right = gappx;
+		gap->bottom = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx * 2;
+	} else if (i == 0) {
+		gap->top = gap->left = gappx;
+		gap->right = gappx / 2;
+		gap->bottom = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx + gappx / 2;
+	} else if (i + 1 < nmaster) {
+		gap->top = gappx;
+		gap->left = gap->right = gappx / 2;
+		gap->bottom = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx;
+	} else {
+		gap->top = gap->right = gappx;
+		gap->left = gappx / 2;
+		gap->bottom = nstack ? gappx / 2 : gappx;
+		gap->minc = gappx + gappx / 2;
+	}
+}
+
+void
+bstackstackgaps(Gap *gap, int nmaster, int nstack, unsigned int i) {
+	if (nstack == 1) {
+		gap->top = nmaster ? gappx / 2 : gappx;
+		gap->left = gap->right = gap->bottom = gappx;
+		gap->tinc = gappx * 2;
+	} else if (i == 0) {
+		gap->top = nmaster ? gappx / 2 : gappx;
+		gap->left = gap->bottom = gappx;
+		gap->right = gappx / 2;
+		gap->tinc = gappx + gappx / 2;
+	} else if (i + 1 < nstack) {
+		gap->top = nmaster ? gappx / 2 : gappx;
+		gap->left = gap->right = gappx / 2;
+		gap->bottom = gappx;
+		gap->tinc = gappx;
+	} else {
+		gap->top = nmaster ? gappx / 2 : gappx;
+		gap->left = gappx / 2;
+		gap->bottom = gap->right = gappx;
+		gap->tinc = gappx + gappx / 2;
+	}
+}
+
+void
+focusmaster(const Arg *arg)
+{
+	Client *c;
+
+	if (selmon->nmaster < 1)
+		return;
+
+	c = nexttiled(selmon->clients);
+
+	if (c)
+		focus(c);
+}
